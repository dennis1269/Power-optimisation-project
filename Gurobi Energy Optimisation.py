# -*- coding: utf-8 -*-
"""
Created on Wed Apr 28 11:36:10 2021

@author: dkhoo
"""
from gurobipy import *
import math
import pandas as pd

# Use pandas to import the csv files as data frames
nodes = pd.read_csv('nodes2.csv')
arcs = pd.read_csv('grid.csv')

A = arcs['Arc']
N = nodes['Node']

# Comm 1 - Generator data [change for your data]
costs = { 13: 83, 14: 65, 32: 71, 38: 74}
uppercosts = { 13: 83*1.3, 14: 65*1.3, 32: 71*1.3, 38: 74*1.3}
supply = { 13: 717, 14: 752, 32: 556, 38: 331}
lowerSupply = { 13: 717*0.6, 14: 752*0.6, 32: 556*0.6, 38: 331*0.6}

# Comm 7 - Gas generator data
gasSupply = 200
gasCost = 77

# Comm 10 - Solar farm data
solarSupply = [0, 20, 120, 110, 20, 0]
solarCost = 42

# Comm 2 - Transmission loss
loss = 0.001

# Comm 3 - Transmission limits [change for your data]
lowlimit = 106
highLimit = 156
highs = [2, 3, 32, 33, 54, 55, 92, 93, 108, 109, 124, 125, 160, 161, 164, 165, 165, 166, 167]

# Calculate lengths of each arc 
distance = [math.hypot(
    nodes['X'][arcs['Node1'][a]]-nodes['X'][arcs['Node2'][a]],
    nodes['Y'][arcs['Node1'][a]]-nodes['Y'][arcs['Node2'][a]]) for a in A]

# Comm 4 - Make a table of demands D[n][t] for clarity later
T = range(6)
D = [[nodes['D'+str(t)][n] for t in T] for n in N]


m = Model("Electrigrid")
m.setParam('MIPGap', 0)

# X gives flow on arc a in time period t
X = {(a,t): m.addVar() for a in A for t in T}

# Y gives amount generated at node n in time period t
Y = {(n,t): m.addVar() for n in N for t in T}

# Z arcs to upgrade
Z = {a: m.addVar(vtype=GRB.BINARY) for a in A}

# G generator to upgrade
G = {n: m.addVar(vtype=GRB.BINARY) for n in N}

# I time interval to turn on gas generator
I = {(n, t): m.addVar(vtype=GRB.BINARY) for n in N for t in T}

# S solar farm to build
S = {n: m.addVar(vtype=GRB.BINARY) for n in N}

# SP power generated by the solar farm
SP = {(n, t): m.addVar() for n in N for t in T}

# UP inefficient power generated
UP = {(n, t): m.addVar() for n in N for t in T}

# LP efficient power generated
LP = {(n, t): m.addVar() for n in N for t in T}

# R node to reduce power at node n, time t
R = {(n,t): m.addVar(vtype=GRB.BINARY) for n in N for t in T}

m.setObjective(quicksum(4*costs[n]*LP[n,t] + 4*uppercosts[n]*UP[n,t] for n in N for t in T if n in costs) +
               quicksum(4 * Y[n, t] * gasCost for n in N for t in T if n not in costs) +
               quicksum(4 * SP[n, t] * solarCost for n in N for t in T), GRB.MINIMIZE)

# Comm 6 - upgrading 3 transmission lines
m.addConstr(quicksum(Z[a] for a in A) == 3)

# Comm 7 - upgrade 1 generator
m.addConstr(quicksum(G[n] for n in N) == 1)

# Comm 8 - can't build generator at node 19
m.addConstr(G[19] == 0)

# Comm 10 - Build 1 solar farm
m.addConstr(quicksum(S[n] for n in N) == 1)

# Comm 9 - turning on the generator for 4 time periods or less only 
m.addConstr(quicksum(I[n, t] for n in N for t in T) <= 4)

# Comm 12 - Can only reduce the node once
for n in N:
    m.addConstr(quicksum(R[n,t] for t in T) == 1)

for t in T:
    
    # Comm 12 - only can reduce usage at 9 nodes for a time period    
    m.addConstr(quicksum(R[n,t] for n in N) <= 9)
    
    for a in A:
        # constrain maximum flow on arc a (unless it is one of the high transmission lines) 
        if not a in highs:
            # Comm 6 - limited by the higher or lower limit depending whether the line will be upgraded
            m.addConstr(X[a,t] <= lowlimit * (1 - Z[a]) + highLimit * Z[a])
            
    for n in N:
        # balance flow at each node, taking into account loss on inflow arcs,
        # adding amount generated to LHS and demand amount to RHS
        # Demand reduce by 10% when it is the node being reduced
        m.addConstr(quicksum(X[a,t]*(1-loss*distance[a]) for a in A if arcs['Node2'][a] == n) + Y[n,t] + SP[n, t] ==
                    quicksum(X[a,t] for a in A if arcs['Node1'][a] == n) + D[n][t]*(1-R[n,t]) + D[n][t]*R[n,t]*0.9)
        
        # Y is constrained by supply at generator nodes and must be 0 everywhere else but the new gas generator
        if n in supply:
            m.addConstr(Y[n,t] <= supply[n])
            # Comm 11 - power generated is separated to efficient and inefficiently generated power
            m.addConstr(Y[n,t] == LP[n,t] + UP[n,t])
            m.addConstr(LP[n,t] <= lowerSupply[n])
            m.addConstr(LP[n,t] >= 0)
            m.addConstr(UP[n,t] <= supply[n]*0.4)
            m.addConstr(UP[n,t] >= 0)
        else:
            # Comm 9 - generated power of the gas generator for that time period can't be more than the limit
            m.addConstr(Y[n, t] <= I[n, t] * gasSupply)
            
        # Comm 9 - the generator upgraded has to be the same
        m.addConstr(I[n, t] <= G[n])
        
        # Comm 10 - solar power generated can't be more than the limit 
        m.addConstr(SP[n, t] <= S[n] * solarSupply[t])
            
                       
m.optimize()

print("Minimum cost = $",m.objVal)
print()

print("Upgrade trasmission lines:")
for a in A:
    if Z[a].x != 0:
        print(a)
print()
for n in N:
    if G[n].x != 0:
        print("Build gas generator at node", n)
        break
    
print()    
print("Turn on gas generator at time:")
for t in T:
    for n in N:
        if I[n,t].x != 0:
            print(t)

print()        
for t in T:
    for n in N:
        if n in costs:
            print("Generator", n, "produce", Y[n,t].x, 'at time', t)
        elif n not in costs and Y[n,t].x != 0:
            print("Gas generator", n, "produce", Y[n,t].x, 'at time', t)
    print("-----------------------------------------")
            
print()    
for n in N:
    if S[n].x != 0:
        print("Build solar farm at node", n)
        break

print()
for t in T:
    for n in N:
        if SP[n,t].x != 0:
            print("Solar power generates", SP[n,t].x, "at time", t)
   
print()
print("Reduce power by 10%")
for t in T:
    for n in N:
        if R[n,t].x > 0:
            print("node", n, "at time", t)
    print("------------------------")

        
